So in golf, obviously the idea is you're supposed to get the ball in the hole with as few strokes as possible. And in code golf, you're supposed to write a program that does something with as few keystrokes as possible, I guess, right? With as few characters as possible. So you're trying to produce the shortest possible program that does a particular thing. And it's a kind of a nerd sport, you know? Although this is a very bad practice. Like if you're really writing software, generally speaking, you do not want the source code to be as small as possible, right? There are things, sometimes you do want the source code to be small, but you have things like minifiers that will deliberately, you know, programs that will automatically compress code. This actually is just an example of a deliberately very short bit of code. This is the code here, and this is the whole of it, and it plays a piece of music which I'm not exactly sure how long it lasts. Definitely 16 minutes, possibly more like 30 minutes before it starts to actually repeat itself. So it produces a fairly large amount of complexity. The song is quite repetitive, but well, I'll play it. So this is... Starts off very simple. And then becomes more complex with time. All of the instruments are essentially the same, but with different parameters. So we can go into the code a little bit. We send the source code to make a C program that will generate audio data, and then we're running it and playing that audio data. Fairly straightforward as a structure. Yeah, and then that's what you get. It takes a few minutes to get actually good, so. So when you run it though, I see one or two warnings pop up. Yeah. Just pay no attention to them. Most of this is the compiler complaining that we are torturing the C language. C is really kind of permissive. It lets you get away with an enormous amount that you really shouldn't be able to. So here, for example, all of these defaults to int. It turns out that if you... C is a strongly typed language, right? Every variable has to have a type. If that's an integer or a float or a character or a pointer or whatever. But it turns out that if you don't specify that, in principle you have to specify it. But if you don't, it just goes, oh, you haven't specified it, I'll assume it's an int. So, which is just an integer. So everything, every variable in here is an integer. Because that way we don't have to waste any characters specifying what it is. And integers work fine for this. So this program really has two main parts. There's a function here called g. And then there's a big loop which calls that function several times. And then calls putchar, which prints a character to the output. So if we remove the pipe to A play, rather than piping the audio data to the speakers, it will just pipe it to the screen and we can look at it. And it looks like this. Kind of fun. So you can see there's kind of structure to it. There's a pattern. It's not random noise. There's kind of waveforms almost. In chiptune music, you tend to have a few basic waveforms that people use all the time because they're easy to generate, right? One of them is the square wave. That has a particular sound which you recognize from the old time game music. There's also the triangle wave. Which is, sounds a bit like a sine wave. But is much easier to generate than a sine wave because it doesn't have that complicated curvy stuff. And the other one is the sawtooth wave. Which is one that goes up and then jumps down and up and jumps down, right? Kind of looks like the teeth of a saw. And this works by sawtooth waves because it turns out that sawtooth waves are super easy to produce just by overflow. What does it mean to say you are overflowing an n-bit representation? You have a fixed number of bits in your number and then you get up to 1, 1, 1, 1, 1, 1, 1. And if you add 1 to it, you do 1 is 1 and 0, carry the 1, carry the 1, carry the 1, carry the 1, carry the 1, and then you're carrying off the end and there's nothing there. So the thing gets reset to 0. So what this is doing in its loop is there's a constant loop here and then putchar is expecting a char. Chars are only 8 bits, right? 8-bit characters. So the way that putchar works is you give it 256, that's like giving it 0. So by having this number that keeps going up, going into putchar, you end up with this sawtooth shape, right? The number goes up and up and up until it goes off the scale and starts again at the bottom. So this is the core on which the thing is built. We just have a really simple loop. We're incrementing i every time, then we're putting that out as a character and printing it. So if we look at that as it comes out, it's just this. And in fact you can see, look, it's very neat. This is what happens if you just output increasingly higher numbers. At the beginning you have a bunch of control codes which don't print, and then you start getting into the characters, you get punctuation, then the numbers, uppercase and then lowercase. These are unprintable again because we've gone off the end of ASCII. It only uses the first half. And then it loops around again. So this is the output of that program. If we then pipe that to APLAY, we get that rather lovely sound. Because the way that APLAY works is it says, and in fact it even tells us, which is kind of nice, playing raw data from standard input unsigned 8-bit at 8,000 Hz. So what that's doing is saying, OK, I'm reading in unsigned 8-bit is the same as a character. I'm reading in one character at a time, 8,000 in a second, and I'm treating the value of each character as sort of the position that the diaphragm of the speaker should be at at that 8,000th of a second. So if you tell it these 256 values up to 0 and down again, you get whatever it is, 8,000 divided by 256. Now let's do that. What is that? I can't do maths. You get a approximately 31 Hz square wave. And in fact we could probably test that. Let's see. There we are. It's a B0, 31.3 Hz. And that's the core idea of how this works. Now if we wanted to make that higher pitched, we just need to increase the rate at which the number goes up, right? So if instead of printing I, we printed I star 2, for example. What does that mean, star 2? Multiplied by 2. So now if we look at it, it should skip every other one. So rather than having 0, 1, 2, 3, we have 0, 2, 4, 6, 8, because it's skipping them out, so it's going twice as steeply. So this ought to be about 60 Hz. It's twice as high and we can look at it. There, now it's a B1 and it's 62.5 Hz. And by this basic function, by multiplying this by different values, you can get any pitch you want. And that's the core of how this makes music. I'm seeing your code there and I'm thinking there's not 16 minutes worth of notes there. So what's going actually on? It runs this loop and then it prints a character. And the way it gets that character is by calling this function G four times, one for each instrument, and just adding up the results. Because in sound, if you take one waveform and just superimpose, and just add the other waveform on top, that just makes the sound of both of them. One of the arguments you pass into the instrument function is the volume that that instrument should play at. And that is set by bit shifting the incremented variable I by a very large number. Bit shifting is an operation, a binary operation, where you take your number and you sort of move the decimal place one point left or right, in principle. So in decimal, if you were doing a shift of that sort, you would be multiplying or dividing by 10, right? By either chopping digits off the end or adding zeros. And in binary, what you're then effectively doing is halving or doubling. And it's a very, very fast, efficient way of halving and doubling numbers. Music kind of works on doubling and halving, in a sense, right? A lot of music. So we can use this to get numbers which vary very slowly, relatively speaking. So you have your number, which is the level of your sawtooth waves, which is going up very quickly, one every 8,000 times a second. And then if you right shift that, for example, 17 times, you get something that only happens once every 2 to the 17 samples, which is, I don't know off the top of my head what 2 to the 17 is, but it's a pretty big number. That then allows you to have something, for example, where it changes from one bar to the next. It lets you have slow changing sections, so that you can have a note that lasts a certain number of samples, or a bar that lasts a certain number of samples, or a phrase that lasts a certain number of samples. And the way that the music is structured, they're always even powers of 2. And it just so happens that that works out quite neatly musically. We'd like to thank Audible.com for sponsoring this episode of Computerphile. If you visit Audible.com slash Computerphile, you can sign up for a 30-day free trial. They've got over 180,000 books to choose from. It's really straightforward. You can browse by category, or you can search by title or author. Today I'd like to recommend The Curious Incident of the Dog in the Night Time, which is a curious title in its own right. It's a book by Mark Haddon. It centres on a boy with Asperger's Syndrome. People without Asperger's Syndrome can probably work out by intuition what's actually happened. And so you kind of know what's happened, but what you get to see in the book is how the boy works out what's happened for himself. So thanks again to Audible.com for sponsoring this episode of Computerphile. Remember, Audible.com slash Computerphile. Sign up for 30 days free. I find it kind of calming to listen to. Like, I found when I was working on it, I would just kind of zone out and listen to it for 10 minutes, and then go, oh, wait, hang on, okay, I want to change this, or I think I can make this bit shorter, or something like that. 