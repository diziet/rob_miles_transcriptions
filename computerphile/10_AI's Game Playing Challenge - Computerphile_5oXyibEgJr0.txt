So, Go is a very, very simple game in terms of the rules, but it's very difficult computationally. There's an enormous depth of complexity that comes out of the very simple rules, which is, I think, part of what makes people love it so much as a game. So, to understand why it's hard for computers, I guess you have to go back a whole bunch and talk about just how computers play games in general, these sort of turn-based strategy games, or that kind of thing, and start with something easy, like Noughts & Crosses. For the sake of internationalization, yes, tic-tac-toe. I like Noughts & Crosses as a name, because it's descriptive, you know, but whatever, yeah. We're going to look at Noughts & Crosses as a game, and I'm going to keep calling it that, I apologise, but... You don't have to apologise, I just want to make sure people understand what we're talking about. Right, right, right, right. That's all. So I'm talking about this game, where you draw your Optothorpe, and then one person, you know, goes here, and one person goes there, and so on, and you alternate placing Noughts and Crosses, and you have to get three in a row. To explain Noughts & Crosses, we should play an even simpler game. So the idea of the game is, we're going to take it in turns to choose left or right, and I'm going to try and get the highest number possible, and you're going to try and get the lowest number possible. It starts off my turn, so if I choose left, for example, it goes down to here. And then it's your turn, and you get to choose left or right. And then which number it ends up on is the outcome of the game. So I want the highest number possible, which is 7. You want the lowest number possible, which is 1. Failing that, I'd prefer the 5 to the 3. This is a perfect information game. What's the difference? What's an imperfect information game? Right, right. So a perfect information game is just a game where all of the players have all of the relevant information. So this is like that, Noughts & Crosses is like that, chess, Go, these sorts of games. You do get games that are not like that. For example, poker. There's hidden information. You can't see each other's hands. So you have to, if you want to write something that's going to play those types of games, obviously it has to work differently to take into account that uncertainty. The question is, should I choose left or right, and how do I make a principled decision? Now, I want the 7. So in principle, I should be going this way, right? You would think I'd want to steer towards the 7. But on the other hand, at this point, it's your choice. You're not going to choose the 7, because I know you want the low number. You're going to choose the 1. If I'm choosing this node, I'm effectively choosing the 1, because I can predict you'll do that. Whereas if I choose the right, then your choice is between a 3 and a 5. So you are going to choose the 3, which is better than the 1, so I should go right. I'm trying to maximize the minimum value. I'm trying to make it so that the best choice available to you is as bad as possible for you, and as good as possible for me. So this is called minimax, because I'm trying to minimize the max. Well, you're trying to minimize the maximum, I'm trying to maximize the minimum. If you see what I mean. And then purely based upon who goes first as to who wins this, right? Right, yeah. This is an absolutely unfair game. I started off saying I want the 7, so maybe I should go left to get the 7. That's one thing. I could look for the highest possible payoff and try and steer towards it. That seems like a reasonable way of playing the game. Not on something this simple, where you can see it obviously fails. But in a more complex game, you might think that, look for the best outcome and try and steer towards it. But you've got to bear in mind that your opponent is steering away from it. Or I could look at it and say, ah, that's the 1. I definitely want to avoid the 1, so I can't possibly steer left. I'm trying to avoid the bad outcome, so I should go right. Or you could look at it and say, okay, how about this entire tree? What's the average here? What's the average goodness of steering left or right? If you take an average on 7 and 1, you get 4. Because 7 plus 1 is 8. If you take the average of 3 and 5, you also get 4. So in this case, they're the same. Does that mean they're both equally good? Well, no, because one of them might end up with a 1 and one of them might end up with a 3. So we're basically saying here, okay, there are different ways to evaluate the choices that you make. Yep, and most of them don't work. Most of them aren't any good. But there is one way that works, which is basically what we did, which is min-max. And so it's a recursive function. So let's try a more complicated game. I'm going to generate some random numbers just using Python to get us a list and then shuffle that list. And there it is. So I'm just going to draw the tree in. Before, it was obvious that I kind of designed those choices to make a point. Here, it's random, so it's a real game now. In many ways, a better game than knots and crosses, because somebody's going to actually win, probably. Whenever you see a tree in computer science, you should always kind of be thinking about recursion, which you've done a video on before, right? So I dive back into this same piece of code. Because a tree has this kind of fractal structure, where ideally you want to have an algorithm where you do the same thing at every part of the tree. So you can have one algorithm that processes the whole tree. So the problem with recursion, a problem with recursion, is infinite recursion, where you have this sort of loop of nested stuff that never ends. You need a degenerate case. You need a case where the answer is easy. And in this case, it's the bottom, right? So if we are at the bottom, first move by the maximizing player, second move by the minimizing player, third move by the maximizing player. So here, which way should I go? I should go with whichever one is bigger. It's the 7, right? So we can effectively call this a 7. It's not the end of the game, but the value of this node is effectively 7, because if this player directs us to there, the game will end with a 7. So you can do that in each case. So this one is a 5, because that's the bigger one. This one is a 3, and this one is the 6. So now these nodes, which before you couldn't do because they didn't have any values, now these look a lot like the nodes below. So here, now we're being the minimizing player, so this will be a 5, and this will be a 3. And now we're being the maximizing player again, who wants to go for the 5. So you can see here that as the maximizing player, the best score I can get is the 5. That's assuming that we're all playing by the same decision-making structure, right? Yes. It helps that it's the optimal decision-making structure in this situation. Okay. But you don't have to make the best choice, right? If you make a mistake, I have values on all the other nodes of the tree. I can make, probably do even better. But the way that min-max works is you end up with making the best possible play you could make as bad as possible. And you're trying to do the same to me. This is a game you can play with your friends. It's a huge fun for everyone. If you can do min-max in your head, and obviously if you have, you can put 16 numbers at the bottom, 32, whatever. But you'll notice, of course, the more numbers you have at the bottom, the more work you've got to do to figure out all of these intervening nodes. And it's tractable for some real games that people play, like Noughts and Crosses. So I could, I'm going to try it. So you take a game like Noughts and Crosses, tic-tac-toe, which is so simple that human beings reliably learn to play it optimally. You start off at the beginning, your Noughts. You have nine choices, right? Because you can go 1, 2, 3, 4, 5, 6, 7, 8, 9. Those are your options. Now it's the Crosses' turn, and there you have eight options, because one of the squares is taken. So 1, 2, 3, 4, 5, 6, 7, 8. And here there's 8, and you see, just quickly this becomes ridiculous. But no game of Noughts and Crosses lasts more than nine turns. Guaranteed, you run out of spaces. We go along, blah, I'm only going to fill in part of the tree now. The point is, what's the degenerate case? Because we're not trying to get numbers. So what you do is, you say, this isn't going to be right. But let's just say, as an example, for a moment, yes, that it's that. So it's a win for Noughts. So if we're playing Noughts, we give this board a score of 1, because we say, 1, we've won. Excellent. A different board, where the Crosses have a win, that's a minus 1, because I really don't want that. And then any state where the game is over, but nobody's won, it's surprisingly difficult. I accidentally won it. This is how hard this game is. There. What can I do? All I do is win. So, uh... So, okay, that's a draw, yeah? That's a draw. So that's a 0. If it's your turn, and you have a move that can win, then that board state is a win. And therefore, you just propagate that up indefinitely, exactly the same way as you would before. Yeah, so you can see how you can plot this out. And it's much too big to actually do. But if you write a computer program to do it, it's not difficult. It's a short program. It doesn't take long to run. And Noughts and Crosses is a solved game, right? So, let's draw the thing for chess. Chess. How much paper have we got? Yeah, let's draw chess. Okay. Yeah. I'm not going to draw chess. Why are you not going to draw chess? Why, you know, it can't be that much more difficult, can it? Yeah, so we need more paper. We need a lot more paper to draw chess. And the issue is, the thing you can see, the thing that's so different here, between the simple game, the very simple game, and Noughts and Crosses, is this thing called branching factor, which is, basically, at each little node, how many branches does the tree have? Simple. In this game, it's two. Here we have two choices. Here we have two choices. Here we have two choices. You always have two choices. This is a longer game. It has more turns. But the branching factor is still two. Every turn, you have two choices you can make. In Noughts and Crosses, okay, firstly, it's more complicated because the branching factor is higher. Secondly, it's complicated because it changes. In the first turn, you have nine choices. The second turn, you have eight, and so on. So the branching factor actually reduces as the game goes on, which is one of the things that makes it easier to compute. So let's think about it. Let's think about chess, then. In chess, the very beginning, let's say, you're white, you're about to start. You've got eight pawns you can move. You can move them forward one. So that's eight possibilities. You've got two. So that's 16, plus you have two knights that are allowed to move because they can jump, so each of those has two. It's another four. I think it's 20. I don't really play chess. But I think it's 20. I think you start off with 20. So I would be drawing 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, all the way up to 20. And then, as the game goes on, much like in Noughts and Crosses, the number of possible moves available to you, legal moves, varies, right? So presumably first it goes up? Yeah. As the game opens up early on, you get more moves available because you've got sort of more space and things can move to several different positions and all of that kind of thing. And then past a certain point, it starts to go down again because pieces get captured. And obviously when you have only a few pieces on the board, you don't have as many moves available to you. But on average, when people play chess, I think the average branching factor is about 35. But chess games generally go longer than 9 turns, right? So when you're calculating the number of nodes in your tree, every turn you're multiplying by the branching factor and that quickly gets completely unmanageable. So you can't just min-max on chess like this. It's computationally completely infeasible. Which is why chess was considered such a big milestone for a long time. If you could make a computer that could play chess, you know, you're not just doing this very trivial brute forcing thing like you're doing for naughts and crosses. If a computer could play chess it would really have to be thinking, right? You can see how here we were taking the end states where we knew the value of the game and then propagating backwards in time from there to give value to these board states that we didn't know the value of before. The problem is there you have to go right from the very end of the game which in chess you can't do. There's just too many possibilities. So you need some way of giving boards values that isn't just propagating backwards from the possibilities from known and, you know, checkmate states. And luckily in chess there's a lot of things you can do about that. The most obvious one is just counting up the pieces. You just say, well a pawn is worth you know, one point and a queen is worth nine. You do some analysis of how games tend to go and you try and figure out how good the pieces you have left are, basically. And the position of them obviously is important but you can get a good, it's a good heuristic. It's a good approximation to just add up the scores of the pieces and say well, you know, this team has both their knights and still has their queen and this only has one knight and has lost their queen so it's really obvious that this team is winning. And therefore that's a good state of the board and you don't need to be able to see all the way to the endgame to know that it's a good state of the board. So the point is because chess's branching factor is so much higher you can't do this thing where you work backwards from the end states. Because the branching factor is too high. You have to start from where you are and look forwards and say okay, hypothetically, if I went this way what would that look like? What boards would that allow me to get to? And then if from there I went here, how would that look? And so on. You don't know whether you're heading towards a win or not. And this is where the heuristics come in, is that they let you put some kind of numbers on these nodes. Like, you know, do I still have my queen in this node? And that should guide you towards winning positions because there tend to be more winning positions in situations where you have your queen. But it's always a heuristic. They're not the chess AI is not seeing forwards in time to a win. They're seeing forwards a certain distance and seeing that it's a good position to be in according to. And obviously it's not just what they have on the board. Like, that's an oversimplification. There's a lot of different heuristics. But the point is you're going to have to evaluate a very, very large number of boards. So you want something you can compute quickly. Because the more boards you can evaluate, the further ahead you can look. And therefore the better you can play even in this game. If you're playing with someone and you can think more moves ahead than them, that gives you a huge advantage because you can force them into a situation where the best move available to them is quite bad. And they didn't think to steer away from that because they didn't look as far ahead as you. What this number means is, if I go here and then play perfectly from that point on, what's the worst score I'd end up getting? This algorithm assumes that your opponent is always going to play the best move that's available to them. Because you're always prepared for the worst possible scenario. So you're only ever pleasantly surprised. Chess is a different ballgame. It's got more complicated manoeuvres. It's got different ways of branching as well as larger branches. So, how does this all feed back into our original point of, go looks pretty straightforward to me. Right. Okay, go. Right. Let's draw go. Okay, we're going to need more paper and a significantly larger universe to put that paper in. Go is difficult for a lot of reasons actually. The first reason that makes go difficult is the branching factor is very high. It's generally more than 200 compared to Chess's 35. So every turn there are at least 200 possible moves you could be making. And so if you imagine me drawing this tree with 200. Come on then, let's draw it. Alright, let's do it. 200. 1, 2, I'm going to run out of pen. 2, 3, 4, I'm going to go in between. 5, 6, 7, 39, 40, 41, 42. Do you know what? I think life's too short, Rob. Yeah, no, you're right. Yeah, this margin is too narrow to contain. It's not going to happen, right? It's not going to happen. And what's more, even, you know, it wasn't going to happen with noughts and crosses, but you can do it in a computer. You can't do that with go. You can't do that with chess, even. And you really can't do it with go. And so even a lot of the cleverness of tree search and pruning and all of the really neat algorithmic improvements people have made for ways of navigating these trees that allow this type of old-fashioned AI to be extremely good at playing chess, better than any human at this point, that approach is not going to work with go and was never going to work with go. And so go became the great, oh my god, past tense, go became the great the great milestone, right, after chess, go was the big one. So, right, we're going with, why is it so hard? The branching factor is huge. That's one thing. But also you don't have a lot of the tricks that you have with chess. You can glance at a chessboard, as I said, and just add up the pieces and say, well, this, you know, white is probably winning or black is probably winning. In go, that's not the case. In the middle of a game of go, between two good players, other good players could not necessarily tell you who's winning right now. Because the specifics of who's winning depends very sensitively on the precise layout of the pieces. It's not just a matter of who has more stones on the board or who has more territory or who has more points or anything like that. It's sort of an emergent property of the pattern, of the layout, which means you don't have these easy shortcuts you can use to evaluate a position. Not only are there ten times as many possibilities to search, there's no obvious way to even tell if a position is good once you're looking at it. Which is, well, this is why this is so impressive, what's been achieved by AlphaGo. To beat the best human players at a game where all of the standard tricks of the trade won't work, and you have to really try something new. 